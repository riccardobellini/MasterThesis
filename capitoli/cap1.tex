\chapter{Introduzione}
\label{chap:intro}
\vspace{1cm}
L'obiettivo di questo capitolo è fornire al lettore un'introduzione agli argomenti 
trattati nel corso della tesi, oltre alle motivazioni e a una panoramica del contesto in 
cui si inquadra questo lavoro.

La Sezione \ref{sec:reconfComp} contiene una descrizione dell'area generale in cui si 
svolge il lavoro, presentando i concetti fondamentali alla base del \emph{reconfigurable 
computing}.

La Sezione \ref{sec:definizioneProblema} descrive quindi la problematica dello 
\emph{scheduling}, oggetto del lavoro, alla luce di quanto descritto nella sezione 
precedente.


\section{Reconfigurable computing}
\label{sec:reconfComp}
Oggigiorno, grazie al progresso tecnologico e alla costante riduzione della dimensione 
dei transistor, è resa possibile l'integrazione di diversi componenti elettronici su un 
singolo chip; questi sistemi, chiamati \ac{SoC} o \ac{MPSoC}, a seconda 
che il microprocessore abbia uno o più core, comprendono oltre al processore anche vari 
moduli funzionali quali blocchi di memoria, connettori per interfacce (USB, FireWire, 
Ethernet ecc.) e altre periferiche, collegati tramite BUS.

Questa integrazione tuttavia apre una serie di problemi, tra cui elevato costo di 
progettazione dei sistemi, bassa affidabilità e necessità di controllare il consumo di 
energia; i problemi sopra citati possono essere risolti grazie all'impiego del 
\emph{reconfigurable computing}.

Con il termine \emph{reconfigurable computing} si intende un'architettura hardware che 
offre la possibilità di essere riconfigurata per implementare qualsiasi logica l'utente 
desideri. Le caratteristiche e il fondamento logico alla base di questo tipo di 
architetture sono descritte nelle prossime sezioni.

\subsection{Da von Neumann alle architetture riconfigurabili}
\label{subsec:cambioParadigma}
In questa sezione vengono illustrati i due principali modelli concettuali di architettura
informatica convenzionalmente trattati: il modello \emph{general-purpose} e il modello
\emph{application-specific}. Vengono presentati pregi e difetti di ciascuna architettura
e viene spiegato come il reconfigurable computing cerca di combinare i vantaggi di
entrambe.

\subsubsection{Il modello general-purpose}
Il modello general-purpose è tuttora ampiamente utilizzato, soprattutto nei personal
computer che utilizziamo tutti i giorni. Questa architettura, proposta dal matematico
John von Neumann nel 1945 \cite{First-Draft-Report-EDVAC}, è basata sul concetto di
\emph{stored-program} computer; la particolarità di uno stored-program computer è quella
di tenere le istruzioni dei programmi e i relativi dati nella memoria RAM. Un computer di
questo tipo contiene una \ac{ISA} e può memorizzare un programma composto da un insieme
di queste istruzioni che guideranno la computazione. Contrariamente alle architetture
precedenti, che potevano eseguire solamente un programma preimpostato, il vantaggio
dell'architettura general-purpose consiste nella possibilità di eseguire codice
arbitrario.

\subsubsection{Il modello application-specific}
Mentre il modello visto nella sezione precedente consente di avere una maggiore
flessibilità a discapito però delle prestazioni che può fornire, il modello
application-specific si posiziona all'estremo opposto rispetto al primo: è infatti
caratterizzato da elevate prestazioni e da un basso consumo di potenza. Questo modello
computazionale viene realizzato mediante l'impiego di \ac{ASIC}, dei circuiti integrati
progettati per svolgere un'unica funzionalità. Questo guadagno in prestazioni comporta
uno svantaggio in termini di costi di produzione e naturalmente una minore flessibilità.

Nella prossima sezione viene spiegato come il reconfigurable computing cerca di combinare
i vantaggi di entrambi gli approcci.

\subsubsection{In medio stat virtus}
Secondo l'informatico Reiner Hartenstein, le architetture riconfigurabili introducono un
cambio di paradigma rispetto all'architettura di von Neumann
\cite{HartensteinParadigmShift}. In un articolo del 1991, Hartenstein et al.~presentano
una nuova metodologia di design per lo sviluppo rapido di \ac{ASIC} ad alte prestazioni
partendo da specifiche di algoritmi ad alto livello \cite{HartensteinNovelASICDesign};
questa metodologia è basata su un nuovo paradigma di macchina sequenziale, chiamata da
Hartenstein \emph{anti macchina}\footnote{Così definita per le sue differenze rispetto al
più convenzionale modello di von Neumann.} o \emph{Xputer}\footnote{Il termine
\emph{Xputer} ha origine dalla necessità dei suoi ideatori di rimpiazzare le prime tre
lettere della parola ``computer'' con un altro prefisso. Non trovandone uno, è stato
deciso che queste lettere fossero rimpiazzate dalla lettera ``x''.}.


\begin{table}[ht]
\caption{Classificazione dei computer effettuata da Nick Tredennick.}
\label{tab:TredennickClassificationScheme}
 \begin{tabular}{l | l}
 \hline
 \textbf{Historic computers} & \textbf{Programming source} \\
 \hline
 resources fixed & none \\
 algorithms fixed & none \\
 \hline
 \textbf{von Neumann computers} & \textbf{Programming source} \\
 \hline
 resources fixed & none \\
 algorithms variable & software \\
 \hline
 \textbf{Reconfigurable computing} & \textbf{Programming source} \\
 \hline
 resources variable & configware \\
 algorithms variable (anti machine) & flowware (data streams)
 \end{tabular}
\end{table}

La Tabella
\ref{tab:TredennickClassificationScheme}


% Nel 1945 il matematico John von Neumann \cite{First-Draft-Report-EDVAC} descrive
% un'architettura informatica che verrà in seguito largamente applicata, soprattutto nei
% personal computer che utilizziamo tutti i giorni.
% L'architettura descritta da von Neumann
% è caratterizzata dalla presenza di una \emph{processor unit} dotata di registri e
% \emph{arithmetic logic unit}, di una unità di controllo formata da un \emph{program
% counter} e un \emph{instruction register}, periferiche per l'input/output dei dati,
% memoria di massa e fisica per memorizzare i dati e le istruzioni dei programmi in
% esecuzione.



\section{Definizione del problema}
\label{sec:definizioneProblema}

